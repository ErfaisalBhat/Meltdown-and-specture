import java.io.*;
import java.util.*;
import java.util.regex.*;
import java.nio.file.*;

/**
 * Comprehensive Microarchitectural Vulnerability Detection Framework
 * Detects Spectre, Meltdown, and related CPU vulnerabilities
 * Cross-platform support with focus on Linux systems
 */ 
public class VulnerabilityDetector {
    
    private SystemInfo systemInfo;
    private MitigationAnalyzer mitigationAnalyzer;
    private VulnerabilityAssessment vulnerabilityAssessment;
    private RiskCalculator riskCalculator;
    
    public VulnerabilityDetector() {
        this.systemInfo = new SystemInfo();
        this.mitigationAnalyzer = new MitigationAnalyzer();
        this.vulnerabilityAssessment = new VulnerabilityAssessment();
        this.riskCalculator = new RiskCalculator();
    }
    
    public static void main(String[] args) {
        System.out.println("=== Microarchitectural Vulnerability Detection Framework ===");
        System.out.println("Scanning system for Spectre, Meltdown, and related vulnerabilities...\n");
        
        VulnerabilityDetector detector = new VulnerabilityDetector();
        VulnerabilityReport report = detector.generateComprehensiveReport();
        
        // Display results
        detector.displayReport(report);
        
        // Save report to file
        detector.saveReport(report, "vulnerability_report.txt");
        
        System.out.println("\n=== Scan Complete ===");
        System.out.println("Report saved to: vulnerability_report.txt");
    }
    
    public VulnerabilityReport generateComprehensiveReport() {
        VulnerabilityReport report = new VulnerabilityReport();
        
        // Collect system information
        report.systemInfo = systemInfo.collectSystemData();
        
        // Analyze mitigation status
        report.mitigationStatus = mitigationAnalyzer.analyzeMitigations();
        
        // Assess vulnerabilities
        report.vulnerabilities = vulnerabilityAssessment.assessVulnerabilities(report.systemInfo);
        
        // Calculate overall risk
        report.riskLevel = riskCalculator.calculateRisk(report);
        
        // Generate recommendations
        report.recommendations = generateRecommendations(report);
        
        return report;
    }
    
    private void displayReport(VulnerabilityReport report) {
        System.out.println("SYSTEM INFORMATION:");
        System.out.println("==================");
        System.out.println("CPU: " + report.systemInfo.cpuModel);
        System.out.println("Vendor: " + report.systemInfo.cpuVendor);
        System.out.println("Architecture: " + report.systemInfo.architecture);
        System.out.println("OS: " + report.systemInfo.operatingSystem);
        System.out.println("Kernel: " + report.systemInfo.kernelVersion);
        System.out.println("Microcode: " + report.systemInfo.microcodeVersion);
        
        System.out.println("\nVULNERABILITY STATUS:");
        System.out.println("====================");
        for (Map.Entry<String, VulnerabilityStatus> entry : report.vulnerabilities.entrySet()) {
            System.out.printf("%-20s: %s\n", entry.getKey(), entry.getValue().status);
        }
        
        System.out.println("\nMITIGATION STATUS:");
        System.out.println("=================");
        for (Map.Entry<String, Boolean> entry : report.mitigationStatus.entrySet()) {
            System.out.printf("%-20s: %s\n", entry.getKey(), 
                entry.getValue() ? "ENABLED" : "DISABLED");
        }
        
        System.out.println("\nRISK ASSESSMENT:");
        System.out.println("================");
        System.out.println("Overall Risk Level: " + report.riskLevel);
        System.out.println("Risk Score: " + report.riskScore + "/100");
        
        System.out.println("\nRECOMMENDATIONS:");
        System.out.println("================");
        for (String recommendation : report.recommendations) {
            System.out.println("• " + recommendation);
        }
    }
    
    private void saveReport(VulnerabilityReport report, String filename) {
        try (PrintWriter writer = new PrintWriter(new FileWriter(filename))) {
            writer.println("Microarchitectural Vulnerability Assessment Report");
            writer.println("Generated: " + new Date());
            writer.println("================================================\n");
            
            writer.println("SYSTEM INFORMATION:");
            writer.println("CPU: " + report.systemInfo.cpuModel);
            writer.println("Vendor: " + report.systemInfo.cpuVendor);
            writer.println("OS: " + report.systemInfo.operatingSystem);
            writer.println("Kernel: " + report.systemInfo.kernelVersion);
            writer.println("Microcode: " + report.systemInfo.microcodeVersion + "\n");
            
            writer.println("VULNERABILITY DETAILS:");
            for (Map.Entry<String, VulnerabilityStatus> entry : report.vulnerabilities.entrySet()) {
                writer.println(entry.getKey() + ": " + entry.getValue().status);
                writer.println("  Details: " + entry.getValue().details);
            }
            
            writer.println("\nRISK ASSESSMENT:");
            writer.println("Risk Level: " + report.riskLevel);
            writer.println("Risk Score: " + report.riskScore + "/100");
            
            writer.println("\nRECOMMENDATIONS:");
            for (String rec : report.recommendations) {
                writer.println("• " + rec);
            }
            
        } catch (IOException e) {
            System.err.println("Error saving report: " + e.getMessage());
        }
    }
    
    private List<String> generateRecommendations(VulnerabilityReport report) {
        List<String> recommendations = new ArrayList<>();
        
        // Check for critical vulnerabilities
        if (report.vulnerabilities.get("Meltdown").status.equals("VULNERABLE")) {
            recommendations.add("Apply KPTI patches immediately - Meltdown vulnerability detected");
        }
        
        if (report.vulnerabilities.get("Spectre V1").status.equals("VULNERABLE")) {
            recommendations.add("Update browser and enable site isolation features");
        }
        
        if (report.vulnerabilities.get("Spectre V2").status.equals("VULNERABLE")) {
            recommendations.add("Apply Retpoline patches and update microcode");
        }
        
        // Check mitigation status
        if (!report.mitigationStatus.get("KPTI")) {
            recommendations.add("Enable Kernel Page Table Isolation (KPTI)");
        }
        
        if (!report.mitigationStatus.get("Retpoline")) {
            recommendations.add("Enable Retpoline compilation flags");
        }
        
        // General recommendations
        if (report.riskLevel.equals("HIGH") || report.riskLevel.equals("CRITICAL")) {
            recommendations.add("Consider hardware upgrade to newer CPU with built-in mitigations");
            recommendations.add("Implement additional monitoring for suspicious activity");
        }
        
        if (report.systemInfo.microcodeVersion.equals("Unknown")) {
            recommendations.add("Update system microcode from CPU vendor");
        }
        
        return recommendations;
    }
}

/**
 * System Information Collection Class
 */
class SystemInfo {
    
    public SystemInfoData collectSystemData() {
        SystemInfoData data = new SystemInfoData();
        
        try {
            // Detect operating system
            data.operatingSystem = System.getProperty("os.name") + " " + System.getProperty("os.version");
            data.architecture = System.getProperty("os.arch");
            
            if (isLinux()) {
                collectLinuxSystemInfo(data);
            } else if (isWindows()) {
                collectWindowsSystemInfo(data);
            } else {
                collectGenericSystemInfo(data);
            }
            
        } catch (Exception e) {
            System.err.println("Error collecting system information: " + e.getMessage());
        }
        
        return data;
    }
    
    private void collectLinuxSystemInfo(SystemInfoData data) throws IOException {
        // Get CPU information from /proc/cpuinfo
        if (Files.exists(Paths.get("/proc/cpuinfo"))) {
            List<String> cpuInfo = Files.readAllLines(Paths.get("/proc/cpuinfo"));
            for (String line : cpuInfo) {
                if (line.startsWith("model name")) {
                    data.cpuModel = line.split(":")[1].trim();
                } else if (line.startsWith("vendor_id")) {
                    data.cpuVendor = line.split(":")[1].trim();
                } else if (line.startsWith("microcode")) {
                    data.microcodeVersion = line.split(":")[1].trim();
                }
            }
        }
        
        // Get kernel version
        data.kernelVersion = executeCommand("uname -r").trim();
        
        // Get additional CPU details using lscpu if available
        try {
            String lscpuOutput = executeCommand("lscpu");
            parseThreadsPerCore(data, lscpuOutput);
            parseCacheInfo(data, lscpuOutput);
        } catch (Exception e) {
            // lscpu not available, continue with basic info
        }
    }
    
    private void collectWindowsSystemInfo(SystemInfoData data) {
        try {
            // Get CPU information using wmic
            String cpuInfo = executeCommand("wmic cpu get name,manufacturer /format:list");
            String[] lines = cpuInfo.split("\n");
            
            for (String line : lines) {
                if (line.startsWith("Name=")) {
                    data.cpuModel = line.substring(5).trim();
                } else if (line.startsWith("Manufacturer=")) {
                    data.cpuVendor = line.substring(13).trim();
                }
            }
            
            // Get OS version
            data.kernelVersion = executeCommand("ver").trim();
            
        } catch (Exception e) {
            collectGenericSystemInfo(data);
        }
    }
    
    private void collectGenericSystemInfo(SystemInfoData data) {
        data.cpuModel = "Unknown";
        data.cpuVendor = "Unknown";
        data.kernelVersion = System.getProperty("os.version");
        data.microcodeVersion = "Unknown";
    }
    
    private void parseThreadsPerCore(SystemInfoData data, String lscpuOutput) {
        Pattern pattern = Pattern.compile("Thread\\(s\\) per core:\\s*(\\d+)");
        Matcher matcher = pattern.matcher(lscpuOutput);
        if (matcher.find()) {
            data.threadsPerCore = Integer.parseInt(matcher.group(1));
        }
    }
    
    private void parseCacheInfo(SystemInfoData data, String lscpuOutput) {
        // Parse L1, L2, L3 cache information
        Pattern l1Pattern = Pattern.compile("L1d cache:\\s*(.+)");
        Pattern l2Pattern = Pattern.compile("L2 cache:\\s*(.+)");
        Pattern l3Pattern = Pattern.compile("L3 cache:\\s*(.+)");
        
        Matcher l1Matcher = l1Pattern.matcher(lscpuOutput);
        Matcher l2Matcher = l2Pattern.matcher(lscpuOutput);
        Matcher l3Matcher = l3Pattern.matcher(lscpuOutput);
        
        if (l1Matcher.find()) data.l1Cache = l1Matcher.group(1);
        if (l2Matcher.find()) data.l2Cache = l2Matcher.group(1);
        if (l3Matcher.find()) data.l3Cache = l3Matcher.group(1);
    }
    
    private boolean isLinux() {
        return System.getProperty("os.name").toLowerCase().contains("linux");
    }
    
    private boolean isWindows() {
        return System.getProperty("os.name").toLowerCase().contains("windows");
    }
    
    private String executeCommand(String command) throws IOException {
        ProcessBuilder processBuilder = new ProcessBuilder();
        
        if (isWindows()) {
            processBuilder.command("cmd.exe", "/c", command);
        } else {
            processBuilder.command("sh", "-c", command);
        }
        
        Process process = processBuilder.start();
        
        StringBuilder output = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
        }
        
        return output.toString();
    }
}

/**
 * Mitigation Analysis Class
 */
class MitigationAnalyzer {
    
    public Map<String, Boolean> analyzeMitigations() {
        Map<String, Boolean> mitigations = new HashMap<>();
        
        try {
            if (isLinux()) {
                analyzeLinuxMitigations(mitigations);
            } else if (isWindows()) {
                analyzeWindowsMitigations(mitigations);
            } else {
                // Default values for unknown systems
                setDefaultMitigations(mitigations);
            }
        } catch (Exception e) {
            System.err.println("Error analyzing mitigations: " + e.getMessage());
            setDefaultMitigations(mitigations);
        }
        
        return mitigations;
    }
    
    private void analyzeLinuxMitigations(Map<String, Boolean> mitigations) throws IOException {
        // Check KPTI status
        mitigations.put("KPTI", checkKPTI());
        
        // Check Retpoline
        mitigations.put("Retpoline", checkRetpoline());
        
        // Check IBRS/IBPB
        mitigations.put("IBRS", checkIBRS());
        mitigations.put("IBPB", checkIBPB());
        
        // Check STIBP
        mitigations.put("STIBP", checkSTIBP());
        
        // Check SSB mitigation
        mitigations.put("SSB", checkSSB());
        
        // Check L1TF mitigation
        mitigations.put("L1TF", checkL1TF());
    }
    
    private boolean checkKPTI() {
        try {
            // Check if KPTI is enabled in kernel command line or dmesg
            String dmesgOutput = executeCommand("dmesg | grep -i kpti");
            if (dmesgOutput.contains("enabled")) {
                return true;
            }
            
            // Check /sys/devices/system/cpu/vulnerabilities/meltdown
            Path meltdownPath = Paths.get("/sys/devices/system/cpu/vulnerabilities/meltdown");
            if (Files.exists(meltdownPath)) {
                String content = Files.readString(meltdownPath);
                return content.contains("Mitigation");
            }
            
            return false;
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkRetpoline() {
        try {
            Path spectreV2Path = Paths.get("/sys/devices/system/cpu/vulnerabilities/spectre_v2");
            if (Files.exists(spectreV2Path)) {
                String content = Files.readString(spectreV2Path);
                return content.contains("retpoline") || content.contains("Mitigation");
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkIBRS() {
        try {
            String cpuFlags = executeCommand("grep flags /proc/cpuinfo | head -1");
            return cpuFlags.contains("ibrs");
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkIBPB() {
        try {
            String cpuFlags = executeCommand("grep flags /proc/cpuinfo | head -1");
            return cpuFlags.contains("ibpb");
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkSTIBP() {
        try {
            String cpuFlags = executeCommand("grep flags /proc/cpuinfo | head -1");
            return cpuFlags.contains("stibp");
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkSSB() {
        try {
            Path ssbPath = Paths.get("/sys/devices/system/cpu/vulnerabilities/spec_store_bypass");
            if (Files.exists(ssbPath)) {
                String content = Files.readString(ssbPath);
                return content.contains("Mitigation");
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkL1TF() {
        try {
            Path l1tfPath = Paths.get("/sys/devices/system/cpu/vulnerabilities/l1tf");
            if (Files.exists(l1tfPath)) {
                String content = Files.readString(l1tfPath);
                return content.contains("Mitigation") || content.contains("Not affected");
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }
    
    private void analyzeWindowsMitigations(Map<String, Boolean> mitigations) {
        // Windows-specific mitigation checks would go here
        // For now, set defaults
        setDefaultMitigations(mitigations);
    }
    
    private void setDefaultMitigations(Map<String, Boolean> mitigations) {
        mitigations.put("KPTI", false);
        mitigations.put("Retpoline", false);
        mitigations.put("IBRS", false);
        mitigations.put("IBPB", false);
        mitigations.put("STIBP", false);
        mitigations.put("SSB", false);
        mitigations.put("L1TF", false);
    }
    
    private boolean isLinux() {
        return System.getProperty("os.name").toLowerCase().contains("linux");
    }
    
    private boolean isWindows() {
        return System.getProperty("os.name").toLowerCase().contains("windows");
    }
    
    private String executeCommand(String command) throws IOException {
        ProcessBuilder processBuilder = new ProcessBuilder();
        
        if (isWindows()) {
            processBuilder.command("cmd.exe", "/c", command);
        } else {
            processBuilder.command("sh", "-c", command);
        }
        
        Process process = processBuilder.start();
        
        StringBuilder output = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
        }
        
        return output.toString();
    }
}

/**
 * Vulnerability Assessment Class
 */
class VulnerabilityAssessment {
    
    public Map<String, VulnerabilityStatus> assessVulnerabilities(SystemInfoData systemInfo) {
        Map<String, VulnerabilityStatus> vulnerabilities = new HashMap<>();
        
        // Assess Meltdown
        vulnerabilities.put("Meltdown", assessMeltdown(systemInfo));
        
        // Assess Spectre variants
        vulnerabilities.put("Spectre V1", assessSpectreV1(systemInfo));
        vulnerabilities.put("Spectre V2", assessSpectreV2(systemInfo));
        
        // Assess other vulnerabilities
        vulnerabilities.put("L1TF", assessL1TF(systemInfo));
        vulnerabilities.put("MDS", assessMDS(systemInfo));
        vulnerabilities.put("Foreshadow", assessForeshadow(systemInfo));
        vulnerabilities.put("ZombieLoad", assessZombieLoad(systemInfo));
        
        return vulnerabilities;
    }
    
    private VulnerabilityStatus assessMeltdown(SystemInfoData systemInfo) {
        VulnerabilityStatus status = new VulnerabilityStatus();
        
        // Meltdown primarily affects Intel CPUs
        if (systemInfo.cpuVendor.toLowerCase().contains("intel")) {
            // Check if system is patched
            if (checkMeltdownMitigation()) {
                status.status = "MITIGATED";
                status.details = "KPTI mitigation detected";
            } else {
                status.status = "VULNERABLE";
                status.details = "Intel CPU without KPTI mitigation";
            }
        } else if (systemInfo.cpuVendor.toLowerCase().contains("amd")) {
            status.status = "NOT AFFECTED";
            status.details = "AMD CPUs are naturally immune to Meltdown";
        } else {
            status.status = "UNKNOWN";
            status.details = "Unable to determine vulnerability status for this CPU vendor";
        }
        
        return status;
    }
    
    private VulnerabilityStatus assessSpectreV1(SystemInfoData systemInfo) {
        VulnerabilityStatus status = new VulnerabilityStatus();
        
        // Spectre V1 affects virtually all modern CPUs
        status.status = "VULNERABLE";
        status.details = "All modern CPUs with speculative execution are affected. " +
                        "Mitigation requires application-level fixes and compiler updates.";
        
        return status;
    }
    
    private VulnerabilityStatus assessSpectreV2(SystemInfoData systemInfo) {
        VulnerabilityStatus status = new VulnerabilityStatus();
        
        // Check for Retpoline and other mitigations
        if (checkSpectreV2Mitigation()) {
            status.status = "MITIGATED";
            status.details = "Retpoline or IBRS mitigation detected";
        } else {
            status.status = "VULNERABLE";
            status.details = "No Spectre V2 mitigation detected";
        }
        
        return status;
    }
    
    private VulnerabilityStatus assessL1TF(SystemInfoData systemInfo) {
        VulnerabilityStatus status = new VulnerabilityStatus();
        
        if (systemInfo.cpuVendor.toLowerCase().contains("intel")) {
            if (checkL1TFMitigation()) {
                status.status = "MITIGATED";
                status.details = "L1TF mitigation enabled";
            } else {
                status.status = "VULNERABLE";
                status.details = "L1 Terminal Fault vulnerability detected";
            }
        } else {
            status.status = "NOT AFFECTED";
            status.details = "Non-Intel CPU, typically not affected by L1TF";
        }
        
        return status;
    }
    
    private VulnerabilityStatus assessMDS(SystemInfoData systemInfo) {
        VulnerabilityStatus status = new VulnerabilityStatus();
        
        if (systemInfo.cpuVendor.toLowerCase().contains("intel")) {
            status.status = "POTENTIALLY VULNERABLE";
            status.details = "Intel CPU may be affected by MDS vulnerabilities";
        } else {
            status.status = "NOT AFFECTED";
            status.details = "Non-Intel CPU, typically not affected by MDS";
        }
        
        return status;
    }
    
    private VulnerabilityStatus assessForeshadow(SystemInfoData systemInfo) {
        VulnerabilityStatus status = new VulnerabilityStatus();
        
        if (systemInfo.cpuVendor.toLowerCase().contains("intel")) {
            status.status = "POTENTIALLY VULNERABLE";
            status.details = "Intel CPU with SGX may be affected by Foreshadow";
        } else {
            status.status = "NOT AFFECTED";
            status.details = "Non-Intel CPU or no SGX support";
        }
        
        return status;
    }
    
    private VulnerabilityStatus assessZombieLoad(SystemInfoData systemInfo) {
        VulnerabilityStatus status = new VulnerabilityStatus();
        
        if (systemInfo.cpuVendor.toLowerCase().contains("intel")) {
            status.status = "POTENTIALLY VULNERABLE";
            status.details = "Intel CPU may be affected by ZombieLoad";
        } else {
            status.status = "NOT AFFECTED";
            status.details = "Non-Intel CPU, typically not affected by ZombieLoad";
        }
        
        return status;
    }
    
    private boolean checkMeltdownMitigation() {
        try {
            if (isLinux()) {
                Path meltdownPath = Paths.get("/sys/devices/system/cpu/vulnerabilities/meltdown");
                if (Files.exists(meltdownPath)) {
                    String content = Files.readString(meltdownPath);
                    return content.contains("Mitigation") || content.contains("Not affected");
                }
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkSpectreV2Mitigation() {
        try {
            if (isLinux()) {
                Path spectreV2Path = Paths.get("/sys/devices/system/cpu/vulnerabilities/spectre_v2");
                if (Files.exists(spectreV2Path)) {
                    String content = Files.readString(spectreV2Path);
                    return content.contains("Mitigation");
                }
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkL1TFMitigation() {
        try {
            if (isLinux()) {
                Path l1tfPath = Paths.get("/sys/devices/system/cpu/vulnerabilities/l1tf");
                if (Files.exists(l1tfPath)) {
                    String content = Files.readString(l1tfPath);
                    return content.contains("Mitigation") || content.contains("Not affected");
                }
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean isLinux() {
        return System.getProperty("os.name").toLowerCase().contains("linux");
    }
}

/**
 * Risk Calculation Class
 */
class RiskCalculator {
    
    public String calculateRisk(VulnerabilityReport report) {
        int riskScore = 0;
        int maxScore = 0;
        
        // Calculate risk based on vulnerabilities
        for (VulnerabilityStatus status : report.vulnerabilities.values()) {
            maxScore += 20;
            switch (status.status) {
                case "VULNERABLE":
                    riskScore += 20;
                    break;
                case "POTENTIALLY VULNERABLE":
                    riskScore += 10;
                    break;
                case "MITIGATED":
                    riskScore += 5;
                    break;
                case "NOT AFFECTED":
                    riskScore += 0;
                    break;
                default:
                    riskScore += 15; // Unknown status
            }
        }
        
        // Adjust score based on mitigations
        int mitigationCount = 0;
        for (Boolean enabled : report.mitigationStatus.values()) {
            if (enabled) {
                mitigationCount++;
            }
        }
        
        // Reduce risk score based on enabled mitigations
        riskScore -= (mitigationCount * 5);
        if (riskScore < 0) riskScore = 0;
        
        // Store numerical score
        report.riskScore = (int) ((double) riskScore / maxScore * 100);
        
        // Determine risk level
        if (report.riskScore >= 80) {
            return "CRITICAL";
        } else if (report.riskScore >= 60) {
            return "HIGH";
        } else if (report.riskScore >= 40) {
            return "MEDIUM";
        } else if (report.riskScore >= 20) {
            return "LOW";
        } else {
            return "MINIMAL";
        }
    }
}

/**
 * Data structures for storing assessment results
 */
class VulnerabilityReport {
    public SystemInfoData systemInfo;
    public Map<String, VulnerabilityStatus> vulnerabilities;
    public Map<String, Boolean> mitigationStatus;
    public String riskLevel;
    public int riskScore;
    public List<String> recommendations;
}

class SystemInfoData {
    public String cpuModel = "Unknown";
    public String cpuVendor = "Unknown";
    public String architecture = "Unknown";
    public String operatingSystem = "Unknown";
    public String kernelVersion = "Unknown";
    public String microcodeVersion = "Unknown";
    public int threadsPerCore = 1;
    public String l1Cache = "Unknown";
    public String l2Cache = "Unknown";
    public String l3Cache = "Unknown";
}

class VulnerabilityStatus {
    public String status = "UNKNOWN";
    public String details = "Unable to determine status";
    public String cveId = "";
    public String severity = "UNKNOWN";
}
